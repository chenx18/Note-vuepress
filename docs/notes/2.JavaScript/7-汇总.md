#### JavaScript
<!-- 1. 折叠所有区域代码的快捷： ctrl + k      ctrl + 0 ; 先按下  ctrl 和 K，再按下 ctrl 和 0 ; ( 注意这个是零，不是欧 )-->

<!-- 2. 展开所有折叠区域代码的快捷：ctrl +k      ctrl + J ;  先按下  ctrl 和 K，再按下 ctrl 和 J   -->

<!-- html css -->
<!-- - 前端页面有哪三层构成
- Doctype的作用,严格模式与混杂模式如何区分
- HTML结构的语义化
- HTML 与 XHTML 区别
- 盒子模型有哪些
- BFC认识
- link和@inmport的区别
- 行内元素和块元素区别
- 浮动的几种方式, 清除浮动
- 浮动元素引起的问题和解决办法
- 常见的几种居中的方法有
- CSS3 的 Flexbox（弹性盒布局模型），以及适用场景
- CSS3新特性
- html5新特性
- 常见兼容性问题 -->

<!-- 基础 -->
<!-- - let cont var 区别
- 作用域与变量声明提升
- 数据类型有哪些 
- 栈 和 堆 认识，
- 栈 和 堆 区别和联系
- 栈和队列的区别
- 内存分配
- 垃圾回收方法
- js中的内存泄露
- 严格模式的限制 -->

<!-- 数据类型 -->
<!-- - null和undefined的区别
- ES6新特性
- 数组常用方法 es6扩展
- 数组去重 
- 判断一个对象是不是数组
- Symbol 值的强制类型转换
- 深拷贝浅拷贝 -->

<!-- 函数 -->
<!-- - this 理解
- call，apply 区别和作用
- 闭包理解 为什么要用 -->

<!-- 面向对象 -->
<!-- - 创建对象的几种方式
- 继承的几种实现方式
- 原型 原型链 认识和特点
- 获取原型方法
- new操作符具体干了什么
- 用过哪些设计模式 -->

<!-- 异步编程 -->
<!-- - 异步操作认识
- 同步和异步的区别
- promise 认识 实现
- Async/Await 认识
- Generator 认识
- setTimeout 和 setInterval 区别 -->

<!-- 模块化开发 -->
<!-- - 模块化开发认识
- js 的几种模块规范
- AMD 和 CMD 规范的区别
- ES6 模块与 CommonJS 模块区别
- requireJS 的核心原理
- Es6 class语法，为什么会出现 class 这种东西
- import和export命令以及export和export default的区别 -->

<!-- 浏览器 -->
<!-- - DOM 和 BOM
- DOM 操作（添加、移除、移动、复制、创建和查找）
- 事件是什么
- 如何阻止冒泡
- 三种事件模型
- 事件委托
- iframe的优缺点
- 浏览器存储有哪些
- cookie、localStorage、sessionStorage、indexDB -->

<!-- http ajax -->
<!-- - JavaScript 的同源策略
- 为什么要有同源限制
- 解决跨域问题
- http和https的区别
- TCP传输的三次握手四次挥手策略
- URL回车后的过程
- GET和POST的区别，何时使用POST
- HTTP状态码
- 创建ajax过程
- XSS 攻击？如何防范 XSS 攻击 -->

<!-- 性能 -->
<!-- - 优雅降级和渐进增强
- 线程与进程的区别
- 对前端架构师的理解 -->



参考文章：  
[2020 前端面试：第一波面试题总结](https://www.cnblogs.com/ZXH-null/p/12294427.html)  
[web前端面试100题](https://zhuanlan.zhihu.com/p/82124513)    
[2019最新Web前端经典面试试题及答案](https://blog.csdn.net/xm1037782843/article/details/80708533)  
[2019年web前端面试题(个人面试总结)](https://www.cnblogs.com/fanfanZhao/p/12193109.html)


<!-- 基础 -->

#### let cont var 区别
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - var 和 let 用以声明 **变量**，const 用于声明只读的 **常量**；  
  - var 声明的变量，不存在块级作用域，在**全局范围内都有效**，let 和 const 声明的，只在它所**在的代码块内有效**；  
  - var 可以先使用，后声明；而 let 和 const 不存在变量提升，所以必须只可先声明，后使用；  
  - let 不允许在相同作用域内，重复声明同一个变量； 
  - const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明；

  </details>

#### 变量声明提升
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - 在当前作用域下，js运行之前，会把带有 var 和 function 关键字声明的 **变量先声明** 并 **安排在内存中**，
  - 也就是所有的变量的声明语句都会提升到代码最顶端，可分为 **普通的变量提升** 和 **函数声明的提升**；
  - 如果在同一个作用域下声明两个相同的变量或者函数，那么**后一个会覆盖前一个**

  </details>

#### 作用域
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - 作用域就是 变量 与 函数 的 **可访问范围**，在某个空间范围内，可以对数据进行读写操作；
  - 作用域有 **全局作用域**、**局部作用域** 和 es6新增的 **块级作用域**；
    - 全局作用域 在代码中任何地方都能访问到；
    - 局部作用域 一般只在固定的代码片段内可访问到
    - 块级作用域 可通过新增命令 let 和 const 声明，在指定块的作用域访问

  </details>

#### 作用域链
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - 作用域链的作用是保证对执行环境 **所有有权访问的变量和函数的有序访问** ，通过作用域链，我们可以访问到外层环境的变量和函数。
  - 本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象
  - 作用域链的前端始终都是当前执行上下文的变量对象。
  - 全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
  - 当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

  </details>

#### 数据类型有哪些 
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - **基本数据类型**: Undefined、Null、Boolean、Number、String, 还有在 ES6 中新增的 Symbol 类型
  - **引用数据类型**：对象类型Object，比如：Object、array、function、date等
  - 区别：
    - 基本数据类型是 **存放在栈内存** 中的 **简单数据段**，**大小确定**，内存空间大小可以分配，可以**直接按值存放访问**  
    - 引用数据类型是 **存放在堆内存** 中的 **对象**，每个空间大小不一样，要根据情况进行特定的配置

  </details>
  
#### 栈 和 堆 认识
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - **栈**:
    - 栈区内存 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等
    - 栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除
  - **堆**：
    - 堆区内存 一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。
    - 存放引用类型，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。

  </details>

#### 栈 和 堆 区别
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - **栈**:
    - 所有在方法中定义的变量都是存放在栈中的，随着方法的执行结束，这个方法的内存栈也自然销毁。存取速度比较快。
  - **堆**：
    - 堆内存中的对象不会随方法的结束而销毁，即便方法结束了，这个对象可能被另一个引用变量所以引用，创建对象是为了反复利用，这个对象将被保存到运行时数据区域。
      
  </details>

#### 栈和队列的区别

#### 内存分配
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - JavaScript 在创建变量（对象，字符串等）时自动进行分配内存
  - 其中 **原始类型**数据值占据空间固定，是简单的数据段，为便于提升变量查询速度，将其存储在 **栈（stack）** 中  
  - 对象类型数据 大小会改变，不固定，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在 **堆（heap）** 中 
  ![存储方式堆栈图](./../../.vuepress/public/img/js/stack-head.png "存储方式堆栈图")  
      
  </details>

#### 垃圾回收方法
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - 当内存不再需要使用时释放；
  - JavaScript内嵌了垃圾收集器，用来跟踪内存分配和使用，以便当分配的内存不在使用时，自动释放；
  - 会 按照固定时间间隔，或代码执行中预定的收集时间，周期性执跟踪哪个变量有用哪个变量无用，对于不在有用的变量打上标记，以备将来收回占用的内存；

  - 垃圾回收策略： 
    - **标记清除**: 当变量进入环境时，将变量标记"进入环境"，当变量离开环境时，标记为："离开环境"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。
    - **引用计数**: 引用计数是跟踪记录每个值被引用的次数，当这个引用计数为0时，被视为准备回收的对象
      
  </details>

#### js中的内存泄露
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - 意外的全局变量引起的内存泄露  
  - 闭包引起的内存泄露  
  - 没有清理的DOM元素引用  
  - 被遗忘的定时器或者回调  
  - 子元素存在引起的内存泄露 
      
  </details>

<!-- 函数 -->

#### this 理解
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。
  - 在实际应用中，一共有四种调用方式：
    - 函数调用模式，this 指向全局对象window。
    - 方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象
    - 构造器调用模式，this 指向实例对象,原型对象里面的方法也指向实例对象
    - apply、call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向
  
  </details>

#### call，apply 区别和作用
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  - call，apply 都是用于改变函数运行时上下文（改变函数内部的this指向）
  - call 和 apply 会调用函数, 并且改变函数内部this指向.
  - call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式  apply 必须数组形式[arg]
  - bind  不会调用函数, 可以改变函数内部this指向.
  - call 常用作做继承. apply 经常跟数组有关系

  </details>

#### 闭包理解 为什么要用
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - 简单来说就是函数嵌套函数，内部函数引用来外部函数的变量；
  - 作用：延伸了变量的作用范围
  - 缺点：容易造成内存泄露（ 会导致垃圾回收机制没有生效，变量被保存来下来。也就是所谓的内存泄漏 ）
  - 优点：可以避免全局变量的污染
  - 三个特性：
    - 函数嵌套函数
    - 函数内部可以引用外部的参数和变量
    - 参数和变量不会被垃圾回收机制回收
  
  </details>

<!-- 面向对象 -->

#### 创建对象的几种方式
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  - [对象创建](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html)

  </details>

#### 继承的几种实现方式
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  - **以原型链的方式来实现继承**
  - **借用构造函数的方式**
  - **组合继承**
  - **原型式继承**
  - **寄生式继承**
  - **寄生式组合继承**
  - [继承](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html)

  </details>

#### 原型 原型链 认识和特点
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  - **构造函数** 是一种特殊的方法。主要用来在创建对象时初始化对象。

  - **原型**: 在JavaScript中,每个构造函数都有 **prototype(原型)**属性, 指向另一个对象   
    - 这个对象包含了可以由该构造函数的所有 **实例共享的属性和方法**，即这个原型对象是用来给实例共享属性和方法的。而每个实例内部都有一个指向原型对象的指针 

  - **对象原型 proto**: 在每个对象都会有一个属性 proto 指向构造函数的 prototype 原型对象

  - **原型链**: 
    - 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。
    - 原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。
  
  - **this**: 指向我们实例对象;

  </details>

#### 获取原型方法
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  - p.proto : **对象原型 proto 指向构造函数的 prototype 原型对象**
  - p.constructor.prototype： **coustructor记录该对象引用于哪个构造函数**
  - Object.getPrototypeOf(p)： **ES6提供的操作方法**

  </details>

#### new操作符具体干了什么
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  - 在内存中创建一个新的空对象。
  - 让 this 指向这个新的对象。
  - 执行构造函数里面的代码，给这个新对象添加属性和方法。
  - 返回这个新对象（所以构造函数里面不需要 return ）。

  </details>

#### 用过哪些设计模式
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

<!-- 数据类型 -->

#### null和undefined的区别
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - **null表示没有对象，即该处不应该有值**
    - 作为函数的参数，表示该函数的参数不是对象
    - 作为对象原型链的终点

  - **undefined表示缺少值，即此处应该有值，但没有定义**
    - 定义了形参，没有传实参，显示undefined
    - 对象属性名不存在时，显示undefined
    - 函数没有写返回值，即没有写return，拿到的是undefined
    - 写了return，但没有赋值，拿到的是undefined

  </details>

#### 严格模式
<details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - ES6引入严格模式
    - 变量必须声明后在使用
    - 函数的参数不能有同名属性, 否则报错
    - 不能使用with语句 (说实话我基本没用过)
    - 不能对只读属性赋值, 否则报错
    - 不能使用前缀0表示八进制数,否则报错 (说实话我基本没用过)
    - 不能删除不可删除的数据, 否则报错
    - 不能删除变量delete prop, 会报错, 只能删除属性delete global[prop]
    - eval不会在它的外层作用域引入变量
    - eval和arguments不能被重新赋值
    - arguments不会自动反映函数参数的变化
    - 不能使用arguments.caller (说实话我基本没用过)
    - 不能使用arguments.callee (说实话我基本没用过)
    - 禁止this指向全局对象
    - 不能使用fn.caller和fn.arguments获取函数调用的堆栈 (说实话我基本没用过)
    - 增加了保留字（比如protected、static和interface）
    
  </details>
    

#### ES6新特性
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>

  - ES6引入来严格模式
  - 新增的变量声明let、const；块级作用域
  - 变量解构赋值
  - 字符串扩展
    - includes()：返回布尔值，表示是否找到了参数字符串。
    - startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
    - endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
  - 数值的扩展
    - Number.isFinite()用来检查一个数值是否为有限的（finite）。
    - Number.isNaN()用来检查一个值是否为NaN。
  - 对象的扩展
    - 对象的解构
  - 数组的扩展
    - 扩展运算符
  - 新增symbol数据类型
  - Set 和 Map 数据结构
    - Set 类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。
    - Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
  - 新增异步编程解决方案 Promise、Generator、async
    - Promise
    - Generator
    - async
  - 新增 类 和 模块
    - class 跟 let、const 一样：不存在变量提升、不能重复声明.
    - 
  - [更多](https://www.cnblogs.com/ZXH-null/p/12294427.html)

  </details>

#### 数组常用方法 es6扩展

#### 数组去重 

#### 判断一个对象是不是数组

#### Symbol 值的强制类型转换

#### 深拷贝浅拷贝

<!-- 异步编程 -->

#### 异步操作认识
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

#### 同步和异步的区别
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

#### promise 认识 实现
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

#### Async/Await 认识
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

#### Generator 认识
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

#### setTimeout 和 setInterval 区别
  <details>
  <summary style="color: #3eaf7c;">
    <span style="cursor:pointer;color:#3eaf7c;font-size:14px;">解析</span>
  </summary>
  
  </details>

<!-- 模块化开发 -->

#### 模块化开发认识

#### js 的几种模块规范

#### AMD 和 CMD 规范的区别

#### ES6 模块与 CommonJS 模块区别

#### requireJS 的核心原理

#### Es6 class语法，为什么会出现 class 这种东西

#### import和export命令以及export和export default的区别

<!-- 浏览器 -->

#### DOM 和 BOM

#### DOM 操作（添加、移除、移动、复制、创建和查找）

#### 事件是什么

#### 如何阻止冒泡

#### 三种事件模型

#### 事件委托

#### iframe的优缺点

#### 浏览器存储有哪些

#### cookie、localStorage、sessionStorage、indexDB

<!-- http ajax -->

#### JavaScript 的同源策略

#### 为什么要有同源限制

#### 解决跨域问题

#### http和https的区别

#### TCP传输的三次握手四次挥手策略

#### URL回车后的过程

#### GET和POST的区别，何时使用POST

#### HTTP状态码

#### 创建ajax过程

#### XSS 攻击？如何防范 XSS 攻击

<!-- 性能 -->

#### 优雅降级和渐进增强

#### 线程与进程的区别

#### 对前端架构师的理解