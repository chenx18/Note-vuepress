# 箭头函数
ES6标准新增了一种新的函数：Arrow Function（箭头函数）。

## 1. 严格模式
  1. 从 ES5 开始，函数内部可以设定为严格模式。
  ```JS
    function doSomething(a, b) {
      'use strict';
      // code
    }
  ```
  2. ES2016 做了一点修改，规定只要**函数参数**使用了**默认值**、**解构赋值**、或者**扩展运算符**，那么函数内部就**不能显式设定为严格模式**，否则会报错。
  ```JS
    // 报错
    function doSomething(a, b = a) {
      'use strict';
      // code
    }

    // 报错
    const doSomething = function ({a, b}) {
      'use strict';
      // code
    };

    // 报错
    const doSomething = (...a) => {
      'use strict';
      // code
    };

    const obj = {
      // 报错
      doSomething({a, b}) {
        'use strict';
        // code
      }
    };
  ```

## 2. 基本用法
  1. ES6 允许使用“箭头”（=>）定义函数
  ```JS
    var f = v => v;

    // 等同于
    var f = function (v) {
      return v;
    };
  ```

  2. 如果箭头函数**不需要参数**或**需要多个参数**，就使用一个圆括号代表参数部分。
  ```JS
    var f = () => 5;
    // 等同于
    var f = function () { return 5 };

    var sum = (num1, num2) => num1 + num2;
    // 等同于
    var sum = function(num1, num2) {
      return num1 + num2;
    };
  ```
## 3. this
  - 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：**箭头函数内部的this是词法作用域，由上下文确定**。
  - this指向的固定化，并不是因为箭头函数内部有绑定this的机制,实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

## 4. 使用注意点 
  箭头函数有几个使用注意点。
  1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

  2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

  3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

  4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。